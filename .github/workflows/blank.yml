name: Generate Languages Report

on:
  push:
    branches:
      - main
  workflow_dispatch:
  schedule:
    - cron: '0 8 * * *'  # todo dia Ã s 8h UTC

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  gerar-idiomas:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: pip install PyGithub requests python-dateutil

      - name: Generate LANGUAGES_REPORT.md
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_USERNAME: ${{ github.repository_owner }}
        run: |
          python - <<PYTHON_CODE
import os
import sys
from github import Github
from collections import defaultdict
from datetime import datetime, timedelta
import json

token = os.environ.get("GH_TOKEN")
username = os.environ.get("GITHUB_USERNAME")

if not token or not username:
    print("âŒ Erro: GH_TOKEN ou GITHUB_USERNAME nÃ£o configurado")
    sys.exit(1)

print(f"ðŸš€ Iniciando anÃ¡lise para: {username}")
print("=" * 60)

try:
    g = Github(token, per_page=100)
    user = g.get_user(username)
    
    repos_data = []
    language_stats = defaultdict(int)
    language_bytes = defaultdict(int)
    language_repos = defaultdict(list)
    
    # Contadores para estatÃ­sticas
    total_stars = 0
    total_forks = 0
    active_repos = 0
    archived_repos = 0
    
    print(f"ðŸ“‚ Coletando repositÃ³rios de {username}...")
    
    for i, repo in enumerate(user.get_repos()):
        try:
            print(f"  [{i+1}] Processando: {repo.name}")
            
            langs = repo.get_languages()
            
            # Detectar se o repositÃ³rio Ã© ativo (atualizado nos Ãºltimos 6 meses)
            is_active = False
            if repo.pushed_at:
                six_months_ago = datetime.utcnow() - timedelta(days=180)
                is_active = repo.pushed_at > six_months_ago
            
            if is_active:
                active_repos += 1
            
            if repo.archived:
                archived_repos += 1
            
            repo_info = {
                "name": repo.name,
                "full_name": repo.full_name,
                "url": repo.html_url,
                "description": repo.description or "Sem descriÃ§Ã£o",
                "languages": langs,
                "primary_language": repo.language or "NÃ£o detectada",
                "stars": repo.stargazers_count,
                "forks": repo.forks_count,
                "watchers": repo.watchers_count,
                "size_kb": repo.size,
                "is_fork": repo.fork,
                "is_archived": repo.archived,
                "is_private": repo.private,
                "is_active": is_active,
                "created_at": repo.created_at.isoformat() if repo.created_at else "",
                "updated_at": repo.updated_at.isoformat() if repo.updated_at else "",
                "pushed_at": repo.pushed_at.isoformat() if repo.pushed_at else "",
                "topics": repo.get_topics(),
                "license": repo.license.name if repo.license else "Sem licenÃ§a"
            }
            
            repos_data.append(repo_info)
            
            # EstatÃ­sticas
            total_stars += repo.stargazers_count
            total_forks += repo.forks_count
            
            # Processar linguagens
            for lang, bytes_count in langs.items():
                language_stats[lang] += 1
                language_bytes[lang] += bytes_count
                language_repos[lang].append({
                    "name": repo.name,
                    "url": repo.html_url,
                    "bytes": bytes_count,
                    "stars": repo.stargazers_count
                })
                
        except Exception as e:
            print(f"  âš ï¸  Erro ao processar {repo.name}: {e}")
            continue
    
    print(f"âœ… AnÃ¡lise concluÃ­da! {len(repos_data)} repositÃ³rios processados.")
    print("=" * 60)
    
    # Ordenar estatÃ­sticas
    sorted_by_repos = sorted(language_stats.items(), key=lambda x: x[1], reverse=True)
    sorted_by_bytes = sorted(language_bytes.items(), key=lambda x: x[1], reverse=True)
    
    # Calcular porcentagens
    total_repos = len(repos_data)
    repos_with_langs = len([r for r in repos_data if r["languages"]])
    
    # Gerar visualizaÃ§Ã£o emojis
    def get_lang_emoji(lang):
        emoji_map = {
            "Python": "ðŸ", "JavaScript": "ðŸ“œ", "TypeScript": "ðŸ“˜", 
            "Java": "â˜•", "C++": "âš™ï¸", "C#": "ðŸ”·", "Go": "ðŸ¹",
            "Rust": "ðŸ¦€", "Ruby": "ðŸ’Ž", "PHP": "ðŸ˜", "Swift": "ðŸ¦",
            "Kotlin": "ðŸŸª", "Dart": "ðŸŽ¯", "HTML": "ðŸŒ", "CSS": "ðŸŽ¨",
            "Shell": "ðŸš", "PowerShell": "ðŸ’»", "R": "ðŸ“Š", "Julia": "ðŸ”¬",
            "Scala": "âš¡", "Elixir": "ðŸ§ª", "Haskell": "Î»", "Lua": "ðŸŒ™",
            "MATLAB": "ðŸ“ˆ", "Objective-C": "ðŸ“±", "Perl": "ðŸª", "TeX": "ðŸ“"
        }
        return emoji_map.get(lang, "ðŸ“")
    
    # Gerar grÃ¡fico de barras ASCII
    def generate_bar_chart(data, max_width=30):
        if not data:
            return ""
        
        max_value = max(data.values())
        result = ""
        
        for lang, value in data.items():
            if max_value > 0:
                bar_length = int((value / max_value) * max_width)
            else:
                bar_length = 0
            
            bar = "â–ˆ" * bar_length + "â–‘" * (max_width - bar_length)
            result += f"{get_lang_emoji(lang)} {lang:<15} {bar} {value}\n"
        
        return result
    
    # Gerar relatÃ³rio markdown
    now = datetime.utcnow()
    
    md = f"""# ðŸ“Š RelatÃ³rio Completo de Linguagens

## ðŸ‘¤ Perfil do Desenvolvedor
**UsuÃ¡rio:** [{username}](https://github.com/{username})  
**Data da anÃ¡lise:** {now.strftime('%d/%m/%Y %H:%M:%S')} UTC  
**RepositÃ³rios analisados:** {total_repos}  
**RepositÃ³rios ativos (Ãºltimos 6 meses):** {active_repos}  
**RepositÃ³rios arquivados:** {archived_repos}  

## â­ EstatÃ­sticas Gerais
**Total de estrelas:** {total_stars:,} â­  
**Total de forks:** {total_forks:,} ðŸ´  
**RepositÃ³rios pÃºblicos:** {len([r for r in repos_data if not r['is_private']])}  
**RepositÃ³rios privados:** {len([r for r in repos_data if r['is_private']])}  
**RepositÃ³rios forkados:** {len([r for r in repos_data if r['is_fork']])}  

---

## ðŸ† TOP 10 LINGUAGENS

### Por NÃºmero de RepositÃ³rios
| # | Linguagem | RepositÃ³rios | % do Total |
|---|-----------|-------------|------------|
"""
    
    for i, (lang, count) in enumerate(sorted_by_repos[:10], 1):
        percentage = (count / total_repos * 100) if total_repos > 0 else 0
        md += f"| {i} | {get_lang_emoji(lang)} {lang} | {count} | {percentage:.1f}% |\n"
    
    md += f"""
### Por Volume de CÃ³digo (Top 5)
| # | Linguagem | Bytes | MB |
|---|-----------|-------|----|
"""
    
    for i, (lang, bytes_count) in enumerate(sorted_by_bytes[:5], 1):
        mb = bytes_count / (1024 * 1024)
        md += f"| {i} | {get_lang_emoji(lang)} {lang} | {bytes_count:,} | {mb:.1f} MB |\n"
    
    md += f"""
---

## ðŸ“ˆ DistribuiÃ§Ã£o Visual

### GrÃ¡fico de RepositÃ³rios por Linguagem
